<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>路由协调器执行时序图</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 40px;
            border-left: 4px solid #2196F3;
            padding-left: 15px;
        }
        .diagram-container {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .mermaid {
            text-align: center;
        }
        .code-block {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>路由协调器执行时序图</h1>

    <div class="diagram-container">
        <div class="mermaid">
sequenceDiagram
    participant Main as main函数
    participant Config as 配置模块
    participant LLM as LLM模型
    participant RouterPrompt as 路由提示词模板
    participant RouterChain as 路由链
    participant Graph as 委托图
    participant Branch as 分支路由
    participant Booking as booking处理程序
    participant Info as info处理程序
    participant Unclear as unclear处理程序
    participant Output as 输出

    Main->>Config: 1. 读取 OPENAI_API_KEY
    Main->>Config: 2. 读取 OPENAI_BASE_URL (可选)
    Config-->>Main: 配置信息
    
    Main->>LLM: 3. 初始化模型(gpt-4o)
    LLM-->>Main: 模型就绪
    
    Main->>RouterPrompt: 4. 创建路由提示词模板
    RouterPrompt-->>Main: 模板创建成功
    
    Main->>RouterChain: 5. 构建路由链
    Note over RouterChain: Template -> ChatModel -> Lambda
    RouterChain-->>Main: 链编译成功
    
    Main->>Graph: 6. 创建委托图
    Main->>Graph: 6.1 添加 booking 节点
    Main->>Graph: 6.2 添加 info 节点
    Main->>Graph: 6.3 添加 unclear 节点
    Main->>Graph: 6.4 添加分支路由
    Main->>Graph: 6.5 连接所有节点到 END
    Graph-->>Main: 图编译成功
    
    Note over Main: 输入请求: "给我预订去伦敦的航班。"
    
    Main->>RouterChain: 7. 执行路由链获取决策
    RouterChain->>RouterPrompt: 7.1 格式化提示词
    RouterPrompt-->>RouterChain: 格式化后的消息
    RouterChain->>LLM: 7.2 调用 LLM 分析请求
    Note over LLM: 分析请求类型<br/>判断应委托给哪个处理程序
    LLM-->>RouterChain: Message{Content: "booker"}
    RouterChain->>RouterChain: 7.3 Lambda 提取决策
    Note over RouterChain: strings.TrimSpace(msg.Content)
    RouterChain-->>Main: 返回决策: "booker"
    
    Main->>Graph: 8. 执行委托图
    Graph->>Branch: 8.1 分支路由判断
    Note over Branch: 根据决策 "booker"<br/>路由到 "booking" 节点
    Branch->>Booking: 8.2 路由到 booking 节点
    Booking->>Booking: 8.3 执行预订处理逻辑
    Note over Booking: bookingHandler(ctx, request)
    Booking-->>Graph: RouterOutput{Output: "预订处理程序处理了请求..."}
    Graph-->>Main: 返回处理结果
    
    Main->>Output: 9. 输出最终结果
    
    Note over Main,Output: 示例2: 信息请求 "意大利的首都是什么？"
    
    Main->>RouterChain: 10. 执行路由链
    RouterChain->>LLM: 10.1 调用 LLM
    LLM-->>RouterChain: Message{Content: "info"}
    RouterChain-->>Main: 返回决策: "info"
    
    Main->>Graph: 11. 执行委托图
    Graph->>Branch: 11.1 分支路由判断
    Branch->>Info: 11.2 路由到 info 节点
    Info->>Info: 11.3 执行信息处理逻辑
    Info-->>Graph: RouterOutput{Output: "信息处理程序处理了请求..."}
    Graph-->>Main: 返回处理结果
    
    Main->>Output: 12. 输出最终结果
        </div>
    </div>

    <h2>执行流程说明</h2>
    
    <div class="code-block">
        <strong>阶段 1: 初始化</strong><br>
        1. 读取环境变量配置（API Key、BaseURL）<br>
        2. 初始化 LLM 模型<br>
        3. 创建路由提示词模板<br>
        4. 构建路由链（Template -> ChatModel -> Lambda）<br>
        5. 创建委托图并添加三个处理程序节点和分支路由
    </div>

    <div class="code-block">
        <strong>阶段 2: 路由决策</strong><br>
        1. 用户请求传入协调器函数<br>
        2. 执行路由链：将请求发送给 LLM 分析<br>
        3. LLM 返回决策（"booker"、"info" 或 "unclear"）<br>
        4. Lambda 函数提取并清理决策字符串
    </div>

    <div class="code-block">
        <strong>阶段 3: 委托执行</strong><br>
        1. 将决策和原始请求传递给委托图<br>
        2. 分支路由根据决策选择对应的处理程序节点<br>
        3. 执行选中的处理程序（booking/info/unclear）<br>
        4. 返回处理结果
    </div>

    <h2>关键组件</h2>
    
    <div class="code-block">
        <strong>路由链 (RouterChain)</strong><br>
        - 输入: map[string]any{"request": "用户请求"}<br>
        - 处理: Template -> ChatModel -> Lambda<br>
        - 输出: string (决策: "booker"/"info"/"unclear")
    </div>

    <div class="code-block">
        <strong>委托图 (DelegationGraph)</strong><br>
        - 输入: RouterInput{Request: "用户请求", Decision: "决策"}<br>
        - 分支: 根据 Decision 路由到对应的处理程序节点<br>
        - 输出: RouterOutput{Output: "处理结果"}
    </div>

    <div class="code-block">
        <strong>处理程序节点</strong><br>
        - booking: 处理预订相关请求<br>
        - info: 处理一般信息查询<br>
        - unclear: 处理无法分类的请求
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                diagramMarginX: 50,
                diagramMarginY: 10,
                actorMargin: 50,
                width: 150,
                height: 65,
                boxMargin: 10,
                boxTextMargin: 5,
                noteMargin: 10,
                messageMargin: 35
            }
        });
    </script>
</body>
</html>

